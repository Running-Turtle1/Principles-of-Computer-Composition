## 指令系统采用不同寻址方式的目的

缩短指令字长，扩大寻址空间，提高编程灵活性。

## 基址寻址和变址寻址

|             | 基址寻址               | 变址寻址               |
| ----------- |:------------------:|:------------------:|
| 有效地址        | $\text{BA=(BR)+A}$ | $\text{BA=(IX)+A}$ |
| 访存次数        | 1                  | 1                  |
| 寄存器内容       | 由OS或管理程序决定         | 由用户设定              |
| 程序执行过程中值可变否 | 不可变                | 可变                 |
| 特点          | 有利于多道程序设计和编制浮动程序   | 有利于处理数组问题和编制循环程序   |

## 题目一 求最短指令字长

> 计算机按照字节编制，指令字长固定且只有两种指令格式、其中三地址指令 29 条，二地址指令 107 条，每个地址字段为 6 位，求最短指令字长

对于三地址字段，高位有 5 位就够了，$2^5>29$ ，还能剩下 3 位给二地址编码，可以设计出来 $3\times 2^6=192>107$ 种二地址指令，所以最少 23 位。

**题目要求按照字节编址，由于指令是存储在存储器中的，因此指令长度应该是 8b 的整数倍。** 

**【答】最短 24b** 

## 题目二 IX + double

> double数组首地址 2000H, 某次循环取元素到了 2100H，IX每次加 1，求 IX ?

偏移了 $100H=16^2$ ，因为 double 占用 8 个字节，$\frac {16^2} 8 = 32$ 。 

## 题目三 寻址方式

> 一条双子长的 LOAD 指令存储在地址为 200 和 201 的存储位置，该指令将指定的内容装入累加器（ACC）中。指令的第一个字指定操作码和寻址方式，第二个字是地址部分。PC 的值是 200，R1 的值是 400，XR的值是 100.
> 
> | 地址  | 主存  |
> | --- | --- |
> | 201 | 500 |
> | 300 | 450 |
> | 400 | 700 |
> | 500 | 800 |
> | 600 | 900 |
> | 702 | 325 |
> | 800 | 300 |

首先，注意到指令的地址部分所在的地址是 201，对应的值是 500。

| 寻址方式      | 有效地址                    | 操作数（装入ACC的值） |
|:---------:|:-----------------------:|:------------:|
| 直接寻址      | EA = A = 500            | 800          |
| 立即寻址      |                         | 500          |
| 间接寻址      | EA = (A) = （500）= 800   | 300          |
| 相对寻址      | EA = （PC) + 2 + A = 702 | 325          |
| 变址寻址      | EA = (XR) + A = 600     | 900          |
| 寄存器R1寻址   | EA = R1                 | 400          |
| 寄存器R1间接寻址 | EA = (R1) = 400         | 700          |

## 间接寻址为什么可以扩大寻址范围 ？

个人理解，间址不会让让有效地址变多，只是可以让其范围变大。

7 位地址偏移采用直接寻址，只能找 7 位。这 7 位作为 16 位主存的低位，可以映射出 16 位的地址，所以寻址范围变大了。

但我感觉还是只能找到 $2^7$ 个地址，只是可以找的范围更大。

## ABOUT ENDIAN

- **Little-endian** : 小端

数据低字节放到低地址

假设我们有一个 4 字节（32 位）的整数 `0x12345678`

地址 0x00 -> 0x78 

地址 0x01 -> 0x56 

地址 0x02 -> 0x34 

地址 0x03 -> 0x12

可以发现与正常的思维逻辑是相反的

- **Big-endian** : 大端

数据高字节放到低地址

（一般数据就这么放）
